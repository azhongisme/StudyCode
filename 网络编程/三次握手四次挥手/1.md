TCP是面向连接的、可靠的协议，建立TCP连接需要三次对话（三次握手），拆除TCP连接需要四次对话（四次挥手）
# 三次握手
服务端调用listen函数后进入监听状态，这时候客户端可以调用connect函数发起TCP连接请求，connect函数会触发三次握手，三次握手完成后，客户端和服务端将建立一个双向的传输通道
## 第一次
客户端向服务端发送一个报文，要求建立一个从客户端到服务端的传输通道
## 第二次
服务端给客户端发送一个报文，一是对客户端要求建立一个从客户端到服务端的传输通道的回应，二是要求建立从服务端到客户端的传输通道
## 第三次
客户端给服务端发送一个报文，对服务端要求建立传输通道的回应
## 细节
listen()的第二个参数 + 1为已连接队列的大小（ESTABLISHED状态，三次握手完成，但没有被accept的socket）

SYN_RECV为半连接

CLOSED是假想状态
# 四次挥手
断开一个TCP连接时，客户端和服务端需要相互总共发送四个包以确认连接的断开，这一过程由客户端或服务端任一方执行close()触发

这里假设主动关闭连接的一端叫A端，对端叫B端
## 第一次

A向B发送关闭A到B的传输通道

## 第二次

B对A的回应

## 第三次

由B发起关闭B到A的传输通道

## 第四次

A对B的回应

## 第二次和第三次不能一起执行的原因

A主动断开连接的时候B可能正在向A发送数据，在第二次的过程中只是关闭A到B的通道没有问题，但是如果还是B向A的数据就需要等待B将数据发送完毕，发送完毕之后再发起关闭B到A的请求

## 细节
主动断开的端在四次挥手之后，socket的状态为TIME_WAIT，该状态持续2MSL

如果是客户端主动断开，TIME_WAIT状态几乎没影响

如果是服务端主动断开，socket没有立即释放，同时端口号只能在2MSL后才能重用